Lecture1-操作系统概论
---

<!-- TOC -->

- [1. 计算机系统概述](#1-计算机系统概述)
  - [1.1. 计算机历史](#11-计算机历史)
  - [1.2. 计算机系统的组成](#12-计算机系统的组成)
  - [1.3. 计算机系统的用户视图](#13-计算机系统的用户视图)
- [2. 计算机硬件系统](#2-计算机硬件系统)
  - [2.1. 计算机硬件系统的组成](#21-计算机硬件系统的组成)
  - [2.2. 冯·诺依曼计算机特点](#22-冯诺依曼计算机特点)
  - [2.3. 存储程序计算机的结构](#23-存储程序计算机的结构)
  - [2.4. 总线及其组成](#24-总线及其组成)
    - [2.4.1. 总线定义](#241-总线定义)
    - [2.4.2. 总线分类](#242-总线分类)
  - [2.5. 中央处理器 CPU](#25-中央处理器-cpu)
    - [2.5.1. 定义](#251-定义)
    - [2.5.2. CPU的组成](#252-cpu的组成)
  - [2.6. 处理器和寄存器](#26-处理器和寄存器)
  - [2.7. 存储器的组织层次](#27-存储器的组织层次)
  - [2.8. 外围设备](#28-外围设备)
    - [2.8.1. 设备类型](#281-设备类型)
    - [2.8.2. 控制方式](#282-控制方式)
    - [2.8.3. SoC片上系统](#283-soc片上系统)
  - [2.9. 用户态和内核态](#29-用户态和内核态)
- [3. 计算机软件系统](#3-计算机软件系统)
  - [3.1. 计算机软件系统组成](#31-计算机软件系统组成)
  - [3.2. 程序员的计算机系统视图](#32-程序员的计算机系统视图)
  - [3.3. 软件开发的不同层次](#33-软件开发的不同层次)
  - [3.4. 计算机程序执行过程](#34-计算机程序执行过程)
- [4. 计算机操作技术的发展](#4-计算机操作技术的发展)
  - [4.1. 操作平台与操作系统](#41-操作平台与操作系统)
  - [4.2. 计算机的手工操作](#42-计算机的手工操作)
  - [4.3. 装入程序的引进](#43-装入程序的引进)
  - [4.4. 引入汇编语言后的计算机控制](#44-引入汇编语言后的计算机控制)
  - [4.5. 引入高级语言后的计算机控制](#45-引入高级语言后的计算机控制)
  - [4.6. 简单批处理系统的操作控制](#46-简单批处理系统的操作控制)
  - [4.7. 操作系统与自动化操作控制](#47-操作系统与自动化操作控制)
- [5. 计算机操作系统 OS](#5-计算机操作系统-os)
  - [5.1. 计算机操作系统(OS, Operating System)的定义 *](#51-计算机操作系统os-operating-system的定义-)
  - [5.2. 操作系统的组成](#52-操作系统的组成)
  - [5.3. 操作系统的类型](#53-操作系统的类型)
    - [5.3.1. 从控制方式来看](#531-从控制方式来看)
    - [5.3.2. 从应用领域领域来看](#532-从应用领域领域来看)
  - [5.4. 操作系统功能和特性](#54-操作系统功能和特性)
    - [5.4.1. 操作系统功能](#541-操作系统功能)
    - [5.4.2. 操作系统特性](#542-操作系统特性)
  - [5.5. 操作系统的形成](#55-操作系统的形成)
- [6. 操作系统资源管理](#6-操作系统资源管理)
  - [6.1. 管理计算机系统的软硬件资源](#61-管理计算机系统的软硬件资源)
  - [6.2. 资源管理最重要的是：屏蔽资源使用的底层细节](#62-资源管理最重要的是屏蔽资源使用的底层细节)
  - [6.3. 资源管理技术](#63-资源管理技术)
  - [6.4. 重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象](#64-重要操作系统的基础抽象进程抽象虚存抽象和文件抽象)
    - [6.4.1. 进程抽象](#641-进程抽象)
    - [6.4.2. 虚存抽象](#642-虚存抽象)
    - [6.4.3. 文件抽象](#643-文件抽象)
    - [6.4.4. 三种抽象综述](#644-三种抽象综述)
    - [6.4.5. 其他资源抽象](#645-其他资源抽象)
  - [6.5. 操作系统虚拟机](#65-操作系统虚拟机)
  - [6.6. 资源的共享与分配方式](#66-资源的共享与分配方式)
- [7. 程序控制角度](#7-程序控制角度)
  - [7.1. 多道程序同时计算](#71-多道程序同时计算)
  - [7.2. 多道程序同时计算例子](#72-多道程序同时计算例子)
  - [7.3. 多道程序设计及优点](#73-多道程序设计及优点)
  - [7.4. 多道程序系统的实现](#74-多道程序系统的实现)
  - [7.5. 多道程序系统的实现要点](#75-多道程序系统的实现要点)
  - [7.6. 多道程序系统需要处理的问题](#76-多道程序系统需要处理的问题)
- [8. 操作系统控制计算机的角度](#8-操作系统控制计算机的角度)
  - [8.1. 计算机系统操作方式](#81-计算机系统操作方式)
    - [8.1.1. 脱机作业控制方式](#811-脱机作业控制方式)
    - [8.1.2. 联机作业控制方式](#812-联机作业控制方式)
  - [8.2. 命令解释程序](#82-命令解释程序)
  - [8.3. 命令解释程序的处理过程](#83-命令解释程序的处理过程)
  - [8.4. OS内核是中断驱动的](#84-os内核是中断驱动的)
- [9. 人机交互的角度](#9-人机交互的角度)
  - [9.1. 人机交互的初期发展](#91-人机交互的初期发展)
  - [9.2. 人机交互发展-WIMP界面](#92-人机交互发展-wimp界面)
  - [9.3. 人机交互发展-多媒体计算机](#93-人机交互发展-多媒体计算机)
  - [9.4. 人机交互发展-虚拟现实系统(临境系统)](#94-人机交互发展-虚拟现实系统临境系统)
- [10. 程序接口的角度](#10-程序接口的角度)
  - [10.1. 系统调用](#101-系统调用)
  - [10.2. 系统调用的实现机制](#102-系统调用的实现机制)
  - [10.3. 系统调用的实现要点](#103-系统调用的实现要点)
  - [10.4. 系统调用的实现流程](#104-系统调用的实现流程)
    - [10.4.1. Transition from user to kernel mode](#1041-transition-from-user-to-kernel-mode)
  - [10.5. 系统调用和函数调用之间的区别](#105-系统调用和函数调用之间的区别)
- [11. 系统结构的角度](#11-系统结构的角度)
  - [11.1. 操作系统软件的规模](#111-操作系统软件的规模)
  - [11.2. 操作系统软件的结构设计](#112-操作系统软件的结构设计)
    - [11.2.1. OS构件](#1121-os构件)
    - [11.2.2. 设计概念](#1122-设计概念)
    - [11.2.3. 操作系统内核](#1123-操作系统内核)
    - [11.2.4. 单内核和微内核对比](#1124-单内核和微内核对比)
    - [11.2.5. 鸿蒙操作系统的软件架构](#1125-鸿蒙操作系统的软件架构)
  - [11.3. 操作系统实现的层次结构](#113-操作系统实现的层次结构)
    - [11.3.1. 操作系统实现的第一种层次结构](#1131-操作系统实现的第一种层次结构)
    - [11.3.2. 操作系统实现的第二种层次结构](#1132-操作系统实现的第二种层次结构)
- [12. 补充](#12-补充)
- [13. 操作系统运行模型](#13-操作系统运行模型)

<!-- /TOC -->

# 1. 计算机系统概述
1. 电子数字计算机，是一种能够自行**按照已设定的程序**进行**数据处理**的电子设备；是软件与硬件相结合、面向系统、侧重应用的**自动化求解**工具
3. 1946年，首台计算机ENIAC诞生于美国。
4. 短短70年，计算机技术迅猛发展，从**科学计算、数据处理**等应用领域，迅速扩展到**实时控制、辅助设计、智能模拟**等诸多领域
5. 今天计算机无所不在，深入社会生活的各个领域，深深改变了当今人类社会的组织行为
6. 计算机系统包括**计算机硬件系统和计算机软件系统**

## 1.1. 计算机历史
1. 1945：电子真空管、机器语言，应用于科学计算
2. 1956：晶体管、批处理控制、Fortran(科学计算的高级语言)/COBOL(数据处理的高级语言)，扩展到数据处理领域
3. 1959：集成电路、多道程序、操作系统/数据库/高级语言，应用领域继续扩展
4. 1976：大规模/超大规模集成电路，向快速化/小型化/系统化/网络化/智能化等方面发展
5. 1980：微机出现，廉价化促使应用领域快速膨胀
6. 1990：图形化人机交互技术，友善化推动了应用人群的快速扩展
7. 2003：移动计算的出现，计算无处不在

## 1.2. 计算机系统的组成
> 计算机系统：包括硬件子系统和软件子系统

1. **硬件**：借助电、磁、光、机械等原理构成的各种物理部件的有机组合，是系统工作的实体，包括CPU，主存储器，I/O控制系统，外围设备等
2. **软件**：各种程序和文件，用于指挥计算机系统按指定的要求进行协同工作
   1. 包括系统软件、支撑软件和应用软件
   2. 关键系统软件是操作系统与语言处理程序
3. 系统软件(操作系统)层是最靠近硬件的一层软件。
4. 操作系统和支撑软件、应用软件之间的主要区别
   1. 操作系统有权利分配资源，支撑软件以及应用软件只能通过操作系统使用资源，两者为控制和被控制的关系。
   2. 操作系统直接作用在硬件上，隔离其他上层软件，并为其提供接口和服务。

## 1.3. 计算机系统的用户视图
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/10.png)

> 系统程序员:面向硬件编程的程序员

# 2. 计算机硬件系统

## 2.1. 计算机硬件系统的组成
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/11.png)

1. 中央处理器
   1. 运算单元
   2. 控制单元
2. 主存储器
3. 外围设备
   1. 输出设备:显示器
   2. 输入设备:键盘、鼠标
   3. 存储设备:硬盘
   4. 网络通信设备:机机通信
4. 总线:连接硬件系统的部件

## 2.2. 冯·诺依曼计算机特点
>冯·诺伊曼等人在1946年总结并明确提出，被称为冯·诺伊曼计算机模型
1. 以运算单元为中心，控制流由指令流产生
2. 采用存储程序原理，面向主存组织数据流
3. 主存是按地址访问、线性编址的空间
4. 指令由操作码和地址码组成
5. 数据以二进制编码

## 2.3. 存储程序计算机的结构
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/12.png)

1. 当前计算机硬件的**经典结构和主流组织**方式
2. **存储器**是这个模型的核心部分

## 2.4. 总线及其组成

### 2.4.1. 总线定义
1. **总线**是计算机各种功能部件之间发送信息的**公共通信干线**，它是CPU、内存、输入输出设备传递信息的**公用通道**
2. 计算机的各个部件通过**总线**相连接，**外围设备**通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。
3. 按照所传输的信息种类，总线包括
   1. 控制线
   2. 数据线
   3. 地址线

### 2.4.2. 总线分类
1. 内部总线:用于CPU芯片内部连接各元件
2. 系统总线:用于连接CPU、存储器和各种I/O模块等主要部件
   1. PCI总线用来连接块设备
   2. E(ISA)主要是用来处理字符型输入设备，输入速度较慢

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/13.png)

3. 通信总线:用于计算机系统之间通信

## 2.5. 中央处理器 CPU

### 2.5.1. 定义
中央处理器是计算机的**运算核心**(Core)和**控制单元**(Control Unit)

### 2.5.2. CPU的组成
1. 运算逻辑部件：一个或多个运算器
2. 寄存器部件：
   1. 通用寄存器
   2. 控制与状态寄存器
   3. 高速缓冲存储器(Cache)
3. 控制部件
   1. 实现各部件间联系的数据、控制及状态的内部总线
   2. 负责对指令译码、发出为完成每条指令所要执行操作的控制信号、实现数据传输等功能的部件

## 2.6. 处理器和寄存器
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/14.png)

1. 运算单元:算术逻辑单元
2. 控制单元:包括指令译码和中断的处理，以及一些重要的控制寄存器
3. 内部总线
4. PC/IR/Flag:重要的控制寄存器
5. MAR/MDR:和主存进行沟通的存储器
6. 不包括的部分
   1. 通用寄存器
   2. Cache
   3. IOAR/IODR

## 2.7. 存储器的组织层次
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/15.png)

> 主存及以上都是易失型设备

## 2.8. 外围设备
  
### 2.8.1. 设备类型
1. 输入设备
2. 输出设备
3. 存储设备
4. 网络设备:机机通信

### 2.8.2. 控制方式
1. 轮询方式:CPU忙式控制，CPU执行内存数据交换
2. 中断方式:CPU启动外设，外设中断CPU，CPU执行内存数据交换
3. DMA方式:CPU启动DMA，DMA执行输入输出与内存数据交换，处理完成后，DMA中断CPU

### 2.8.3. SoC片上系统
1. 片上系统(SoC, System ona Chip)
2. 在单个芯片上集成一个完整的系统，对所有或部分必要的电子电路进行包分组的技术
3. 所谓完整的系统一般包括中央处理器(CPU)、存储器、以及外围电路等
4. SoC是与其它技术并行发展的，如绝缘硅(SOI)，它可以提供增强的时钟频率，从而降低微芯片的功耗


## 2.9. 用户态和内核态
1. 用户态和内核态之间可以相互转化
2. 内核态可以进行系统调用，完成中断处理

# 3. 计算机软件系统

## 3.1. 计算机软件系统组成
1. 系统软件
   1. 操作系统：实施对各种软硬件资源的管理控制
   2. 应用程序：为方便用户所设，如文本编辑等
   3. 语言处理程序：把用汇编语言/高级语言编写的程序，翻译成可执行的机器语言程序
   4. 数据库管理系统
2. 支撑软件：支持用户使用计算机的环境，提供开发工具，也可以认为是系统软件的一部分。
   1. 接口软件
   2. 工具软件
   3. 环境数据库等
3. 应用软件：是用户按其需要自行编写的专用程序

## 3.2. 程序员的计算机系统视图
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/16.png)

1. 计算机硬件系统:机器指令
2. 操作系统与实用软件:扩展机器指令,系统调用、操作系统与应用软件
3. 数据库语言:数据库管理系统，可以不再对流进行处理，而是处理对象式和关系式
4. 语言处理系统:高级语言，变向对目标进行解决
5. 支撑软件:使用软件工程工具

## 3.3. 软件开发的不同层次
1. 计算机硬件系统：机器语言
2. 操作系统之资源管理：机器语言+广义指令(扩充了硬件资源管理)
3. 操作系统之文件系统：机器语言+系统调用(扩充了信息资源管理)
4. 数据库管理系统：+数据库语言(扩充了功能更强的信息资源管理)
5. 语言处理程序：面向问题的语言

## 3.4. 计算机程序执行过程
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/1.png)

> 源程序是如何在硬件平台上进行处理如上图进行描述

# 4. 计算机操作技术的发展

## 4.1. 操作平台与操作系统
1. 任意一台机器都有其操作平台与操作系统
   1. 例子: 洗衣机
      1. 确定水量、洗衣时间、洗涤强度、洗衣粉
      2. 启动按钮
      3. 指示灯显示工作状态
   2. 这一方式可以总结为:开关表示，按钮控制，亮灯显示操作平台的精细化和系统化，产生了操作系统
2. 计算机也不例外，由此产生了极为系统的计算机操作平台——计算机操作 系统
3. 使用汇编语言的程序的编译运行程序为：汇编、执行
4. 使用高级语言的程序的编译运行程序为：编译、链接、执行

## 4.2. 计算机的手工操作
1. 开关表示，按钮控制，亮灯显示

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/18.png)

2. 问题：手工操作速度与电子计算速度不匹配
3. 最简单的操作系统的操作，非常复杂并且容易出错。

## 4.3. 装入程序的引进
1. 引入卡片和纸带描述程序指令与数据
2. 引入装入程序(Loader)
   1. 自动化执行程序装入，必要时进行地址转换
   2. 通常存放在ROM中
3. 一般执行顺序是从机器语言程序到装入程序，再到内存储器。
4. 装入程序的数据是非常麻烦的

## 4.4. 引入汇编语言后的计算机控制
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/20.png)

> 添加进入高级语言之后，连接程序时非常重要的，将一些共有的操作进行封装

## 4.5. 引入高级语言后的计算机控制
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/21.png)

> 磁带相对更加不容易断裂

## 4.6. 简单批处理系统的操作控制
1. 简单批处理系统的处理过程
   1. 引入作业控制语言，用户编写作业说明书，描述对一次计算机求解(作业)的控制
   2. 操作员控制计算机成批输入作业，成批执行作业
2. 这一方式明显**缩短**了手工操作的时间，提高了**计算机系统利用率**
3. 这一阶段，磁带的出现，使得卡片与纸带等机械输入方式得以进一步提高
4. 简单批处理系统本质上是一种**半自动化**的操作方式，不算操作系统
   1. 解决了**手工操作和计算机机械操作**不匹配的矛盾
   2. 没有解决了**手工操作与中央处理器电子操作速度**不匹配的矛盾
   3. 进一步减少了慢速外设的影响
5. 简单批处理系统的解决方案是允许多道程序同时运行，但是没有达到真正的多道程序设计

## 4.7. 操作系统与自动化操作控制
1. 电子计算速度与机械I/O速度的矛盾：你在输，我在等
2. 在程序执行过程中能否同时输入作业重叠时间
   1. 需要多道程序同时执行
   2. 程序切换需要高速的外存储设备
3. 磁盘设备出现：计算机操作系统浓墨登场，实现了计算机系统的自动化控制
4. 机械I/O速度是难以显著提升的。
5. 为什么随机存储可以成为计算机操作系统出现的基础?(课本267页)
   1. 随机存储
   2. 线性存储:线性存储
6. 为什么随机存取很重要呢？
   1. 因为操作系统引入了虚拟存储，虚拟分页，虚拟的地址空间需要1000个页框，但是我只给了100个页框进行使用，命中即为是这100个。
   2. 如果没有命中，则缺页，启动缺页中断处理，然后到磁盘中查找对应的页调入，寻找相对于磁带的形式而言非常大。让用户感觉不到有磁带的延时。

# 5. 计算机操作系统 OS
  
## 5.1. 计算机操作系统(OS, Operating System)的定义 *
1. OS是计算机系统**最基础**的系统软件，管理软硬件资源、控制程序执行，改善人机界面，提供各种服务，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。
   1. 定位(**计算机系统最基础的系统软件**):处于硬件之上(最接近硬件)的系统软件
   2. 用途(**管理软硬件资源**):
      1. 管理硬件资源，首先进行抽象，提供系统调用和中断等服务给上层资源使用。
      2. 管理软件资源，管理文件抽象的数据资源以及在操作系统环境下可能被启动运行的应用程序，并创建成进程，然后再为进程分配相应的资源，包括CPU资源、处理器资源、外设资源和程序运行中的文件系统需要的资源。也可以映射为三个基本抽象。
   3. 用途(**控制程序的执行**):在操作系统环境下，加入的软件系统的实体，要被创建成一些进程，并由操作系统来统管所有的进程。
   4. 用途(**改善人机界面**):操作系统最终是呈现给终端用户使用，必须改善用户界面，方便人群使用。由于操作系统定位的人群不同，则风格不同，比如服务器的命令行控制。
   5. 用途(**合理组织计算机工作流程**):体现资源调度和管理
   6. 总结(**为用户使用计算机提供良好运行环境**)
2. 简而言之，操作系统是方便用户、管理和控制计算机软硬件资源的系统程序集合
   1. 从**用户角度**看，OS管理计算机系统的各种资源，扩充硬件的功能，控制程序的执行
   2. 从**人机交互**看，OS是用户与机器的接口，提供良好的人机界面，方便用户使用计算机，在整个计算机系统中具有承上启下的地位
   3. 从**系统结构**看，OS是一个大型软件系统，其功能复杂，体系庞大，采用层次式、模块化的程序结构
3. 操作系统是软件系统的核心，与硬件一同构成了各种软件的基础服务平台。
4. 操作系统在计算机系统中的作用(P11)：
   1. 服务用户：操作系统作为用户接口和公共服务程序。
   2. 进程交互：操作系统作为进程执行的控制者和协调者。
   3. 系统实现：操作系统作为扩展机或虚拟机。
   4. 资源管理：操作系统作为资源你的管理者和控制者。

## 5.2. 操作系统的组成

> 文件系统的核心目标是实现按名存取

| 操作系统组成的子系统 | 描述                                                                                                            |
| -------------------- | --------------------------------------------------------------------------------------------------------------- |
| 进程调度子系统       | 负责管理调度进程                                                                                                |
| 进程通信子系统       | 负责进程间的通信解决方案                                                                                        |
| 内存管理子系统       | 负责管理内存与虚存                                                                                              |
| 设备管理子系统       | 负责管理我们的外围设备                                                                                          |
| 文件管理子系统       | 负责管理文件信息，提供系统调用，Linux需要考虑如何在线性的地址空间，如何建立非线性的层次式目录结构以实现按名存储 |
| 网络通信子系统       | 实现网络操作系统，涉及到分布式等                                                                                |
| 作业控制子系统       | 提供用户操作控制计算机系统，在服务器、云计算等资源虚拟化环境下                                                  |

## 5.3. 操作系统的类型

### 5.3.1. 从控制方式来看
1. 多道批处理操作系统
   1. 采用**脱机控制**方式
   2. 程序员通过作业说明来描述对作业的控制方式
   3. 操作员根据说明书来成批加载作业和控制计算机系统
   4. 优点：资源利用率高，作业吞吐量大
   5. 缺点：作业周转周期长、不具备交互式计算能力，不利于程序的开发和测试
2. 分时(Time Sharing)操作系统:交互控制，核心是划分CPU的时间
   1. 时间片调度思想:CPU的时间等分
   2. 在终端上进行交互式会话，具有同时性、独立性、及时性和交互性的特点。
   3. 和批处理操作系统区别：追求目标、适应作业、资源利用率不同。
   4. Eg:100MHz的CPU，如果有10个终端用户使用，那么一个终端用户大概使用10MHz的CPU来使用
3. 实时(Real Timing)操作系统:支持分时交互，又有大量的进程处理突发任务
   1. 硬实时:最严格的实时操作系统
   2. 软实时:可以在某些地方不严格
4. 如果某个操作系统兼具批处理、分时和实时处理的全部或两种功能，则可以被称为通用操作系统。

### 5.3.2. 从应用领域领域来看
1. 服务器操作系统:并行操作系统
2. 网络操作系统:分布式操作系统
3. 个人机操作系统:手机操作系统
4. 嵌入式操作系统:传感器操作系统

## 5.4. 操作系统功能和特性

### 5.4.1. 操作系统功能
1. 处理器管理：对处理器的管理和调度最终归结为对进程和线程的管理和调度，最大限度提高处理器利用率。
2. 存储管理：管理内存资源，提供存储空间利用率。
3. 设备管理：管理各种外部设备，完成用户提出的I/O请求;加快数据传输速度，发挥设备的并行性，提高设备的利用率;提供设备驱动程序和中断处理程序,为用户隐蔽硬件操作细节，提供简单的设备使用方法
4. 文件管理：针对信息资源的管理。
5. 联网与通信管理：
   1. 网络资源管理
   2. 数据通信管理
   3. 应用服务
   4. 网络管理

### 5.4.2. 操作系统特性
1. 并发性：
   1. 并发性指两个或两个以上的活动或事件在同一时间间隔内发生。
   2. 采用并发技术的系统又称多任务处理系统
   3. 并行性指两个或两个以上的活动或事件在同一时刻发生，存在于多CPU系统中。
   4. 并行一定并发，并发不一定并行
   5. 并发的关键技术是对系统的多个运行程序(进程)进行切换的技术。
2. 共享性：
   1. 计算机系统中的资源可以被多个并发执行的程序共同使用，而不是被某个程序独占
   2. 划分：
      1. 透明资源共享：必须处理好资源隔离和授权访问问题
      2. 独占资源共享：排他性地使用一类资源
3. 并发性和共享性互相依存，没有并发就不必讨论共享，做不到共享也就导致做不到并发。
4. 异步性(随机性)：并发活动导致随机事件的产生。操作系统需要保证只要运行环境相同，多次运行同一程序，都会获得完全相同的计算结果。

## 5.5. 操作系统的形成
1. 中断和通道技术的出现使得硬件具备并行工作的能力。

# 6. 操作系统资源管理
> 1. 解决物理资源数量不足的问题
> 2. 合理分配资源
> 3. 实现资源的易用性

1. 硬件资源：处理器、内存和外设(字符型设备等)
2. 信息资源(可以理解为软件资源)：数据和程序

## 6.1. 管理计算机系统的软硬件资源
1. 处理器资源：哪个程序占有处理器运行？
2. 内存资源：程序/数据在内存中如何分布？
3. 设备管理：如何分配、去配和使用设备？
4. 信息资源管理：如何访问文件信息？
5. 信号量资源：如何管理进程之间的通信？信号量(->数据结构)与PV原理(->原语操作):重要

## 6.2. 资源管理最重要的是：屏蔽资源使用的底层细节
1. 驱动程序：最底层的、直接控制和监视各类硬件(或文件)资源的部分
2. 职责是**隐藏底层硬件的具体细节**，并向**其他部分提供一个抽象的、通用的接口**
3. 比如说：打印一段文字或一个文件，既不需知道文件信息存储在硬盘上的细节，也不必知道具体打印机类型和控制细节

## 6.3. 资源管理技术
1. 复用
   1. 空分复用共享，例如内存和外存资源是空分复用的关系、磁盘上进行空分复用
   2. 时分复用共享
      1. 按照资源物理特性分为
         1. 独占式
         2. 时分共享式
      2. 例如：磁带机与磁盘机
2. 虚拟(虚拟性)
   1. 本质：对资源进行转化、模拟或整合，将一个物理资源变成多个逻辑上的对应物，也可以将多个物理资源编程单个逻辑上的对应物，达到多个用户共享一套计算机物理资源的目的。
   2. 复用划分实际存在的物理资源，虚拟则实现假想的虚拟同类资源。
   3. 例子：虚拟内存、虚拟文件系统(VFS)。
3. 抽象：
   1. 目的：为了处理系统复杂性，重点解决资源易用性。
   2. 资源抽象：不考虑物理细节而对资源执行操作的技术。
   3. 抽象层次越高，使用越方便。
4. 组合使用多种资源管理技术

## 6.4. 重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象
1. 计算机物理资源划分：
   1. 计算及存储类：包含处理器和内存等
   2. 接口类：包含外存和外部处理器等
2. 为方便对物理资源的管理和控制，现代操作系统引入了：进程、虚拟和文件，形成了三种最基础的抽象。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/3.png)

### 6.4.1. 进程抽象
1. 进程是对进入内存的执行程序在处理器上操作的状态集的一个抽象。
2. 进程是并发和并行操作的基础。
3. 进程可以使用fork()、wait()、exec()等系统调用。
4. 进程的执行依赖于内存和设备上的信息资源。

### 6.4.2. 虚存抽象
1. 虚拟内存的本质是在物理内存的基础上创建一个新的抽象概念。
2. 虚存抽象保证了安全性
3. 进程的执行还依赖于存放在内存中的程序和数据，而他们往往存储在设备上，所以我们需要对设备进行抽象。

### 6.4.3. 文件抽象
1. 文件是设备的一种抽象，通过将文件的字节映射到存储设备的物理块中来实现文件抽象。
2. 提供了open()、read()和write()等方法来控制和使用文件。
3. 磁盘、光盘等外存设备都有极其复杂的物理接口，通常我们将其抽象，使得所存放柜的信息可以表示为一个命名的逻辑字节流，称其为文件，这是资源抽象的一个特例。
4. 为了管理方便，操作系统将除处理器和内存以外，将磁盘和其他外部设备资源都抽象为文件，减少系统开销，复用系统调用。

### 6.4.4. 三种抽象综述
1. 操作系统基本任务
   1. 防止硬件资源被失控的应用程序滥用。
   2. 屏蔽复杂的硬件操作细节。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/2.png)

### 6.4.5. 其他资源抽象
1. 与设备抽象相似，操作系统还对其他底层硬件资源进行了抽象。
2. 资源抽象也可以用于没有特定基础硬件的软甲资源，如信息、信号量和共享数据结构。
3. 对象和抽象数据类型是常用于创建抽象资源的软件机制。

## 6.5. 操作系统虚拟机
1. 物理CPU：时分共享复用，实现虚处理器
2. 物理内存：虚拟存储技术，实现虚内存
3. 独占型I/O设备：SPOOLing技术，实现虚设备
4. 磁盘设备：通过文件抽象，实现虚外存

## 6.6. 资源的共享与分配方式
1. 资源共享方式
   1. **独占**使用方式:只能被一个程序使用
   2. **并发**使用方式:在同一时段可以被多个程序使用，虚拟共享Spooling
2. 资源分配策略:对于独占使用方式的分配方式
   1. **静态**分配方式，运行程序进入内存前已经将所有的内存完成分配，好处是不会死锁，坏处是效率低，使用效率低
   2. **动态**分配方式，随用随分配，可能导致死锁
   3. **资源抢占**方式，如果你在使用，我的优先级高，我可以抢过来使用，但是涉及到保存状态的问题

# 7. 程序控制角度

## 7.1. 多道程序同时计算
1. CPU速度与I/O速度不匹配的矛盾，非常突出
2. 只有让多道程序同时进入内存争抢CPU运行，才可以够使得CPU和外围设备充分并行，从而提高计算机系统的使用效率
3. 例如：百度的搜索引擎

## 7.2. 多道程序同时计算例子
| ![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/5.png) | ![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/23.png) |
| ------------------- | -------------------- |

1. 对于甲、乙两道程序，如果两个程序的操作之间是没有冲突的
   1. 独占计算机单道运行时均需1小时，占用CPU时间18分钟，CPU利用率为30％
   2. 按多道程序设计方法同时运行，CPU利用率50%，由于要提供36分钟的CPU时间，大约运行72分钟。考虑到OS调度开销，实际花费时间还要长些，如80分钟
2. 就处理两道作业而言，提高效率33％，整体的系统的吞吐率会高
3. 就单道作业而言，延长执行时间20分钟，即延长了33％的时间
4. 可以采用概率方法计算CPU的利用率，假设程序平均等待I/O 操作的时间占其运行时间的比例为P，当内存中有n道程序时，所有程序都等待I/O操作的概率是$P^n$，即此时CPU利用率=$1-P^n$，其中n称为多道程序的道数或度数

## 7.3. 多道程序设计及优点
1. 多道程序设计：**指允许多个作业(程序)同时进入计算机系统的内存并启动交替计算的方法**
2. 多道程序设计的特点
   1. CPU与外部设备充分并行
   2. 外部设备之间充分并行
   3. 发挥CPU、内存和设备的使用效率
   4. 提高单位时间的算题量(吞吐率)
3. 多道程序设计的主要缺点：延长了作业的周转时间。

## 7.4. 多道程序系统的实现
1. 进入内存执行的程序建立管理实体：**进程**动态概念，驻留在操作系统中
2. OS应该能管理与控制进程程序的执行
3. OS协调管理各类资源在进程间的使用
   1. 处理器的管理和调度
   2. 主存储器的管理和调度
   3. 其他资源的管理和调度
   4. 信号量的管理和调度

## 7.5. 多道程序系统的实现要点
1. 如何使用资源：调用操作系统提供的服务例程(如何陷入操作系统)
2. 如何复用CPU：调度程序(在CPU空闲时让其他程序运行)
3. 如何使CPU与I/O设备充分并行：设备控制器与通道(专用的I/O处理器)
4. 如何让正在运行的程序让出CPU：中断(中断正在执行的程序，引入OS处理)，能够恢复现场而不是从头运行
5. 需要注意的是道数是受到物理资源的制约的。

## 7.6. 多道程序系统需要处理的问题
1. 存储保护与程序浮动
2. 处理器管理与分配
3. 资源管理与调度

# 8. 操作系统控制计算机的角度

## 8.1. 计算机系统操作方式
1. OS规定了合理操作计算机的工作流程
2. OS的操作接口——系统程序：OS提供给用户的功能级接口，为用户提供的解决操作计算机和计算共性问题的所有服务的集合
3. OS的两类作业级接口
   1. 脱机作业控制方式：作业控制语言，比如批处理
   2. 联机作业控制方式：操作控制命令

### 8.1.1. 脱机作业控制方式
1. 脱机作业控制的各角色工作
   1. OS提供**作业说明语言**，通过作业控制程序自动控制作业的执行
   2. 用户编写**作业说明书**，确定作业加工控制步骤，并与程序数据一并提交
   3. 操作员通过控制台输入作业
2. 例：批处理OS的作业控制方式，UNIX的shell程序，DOS的bat文件
3. 多道批处理：可以多道作业交替占用处理器运行

### 8.1.2. 联机作业控制方式
1. 联机作业控制方式的各角色工作
   1. 计算机提供终端
   2. 用户登录系统
   3. OS提供命令解释程序
   4. 用户进行联机输入命令，直接控制作业步的执行
2. 例：分时OS的交互控制方式
3. 图形化无非就是把上述操作图形化了而已

## 8.2. 命令解释程序
1. 命令解释程序：接受和执行一条用户提出的对作业的加工处理命令
2. 当一个新的批作业被启动，或新的交互型用户登录进系统时，系统就自动地执行命令解释程序，负责读入控制卡或命令行，作出相应解释，并予以执行
3. 实现方式
   1. 命令解释语言包含命令的执行代码，一旦收到命令后，就转向相应的命令处理代码执行，执行过程中往往会使用到系统调用
   2. 由专用的实用程序实现，执行时将命令所对应的命令处理文件装入内存
4. 会话语言：可编程的命令解释程序，UNIX的Shell
5. 图形化的命令控制方式
6. 多通道交互的命令控制方式

## 8.3. 命令解释程序的处理过程
1. OS启动命令解释程序，输出命令提示符，等待键盘中断/鼠标点击/多通道识别
2. 每当用户输入一条命令(暂存在命令缓冲区)并按回车换行时，申请中断
3. CPU响应后，将控制权交给命令解释程序，接着读入命令缓冲区内容，分析命令、接受参数，执行处理代码
4. 前台命令执行结束后，再次输出命令提示符，等待下一条命令
5. 后台命令处理启动后，即可接收下条命令

## 8.4. OS内核是中断驱动的
> 等价表述

1. OS内核是中断驱动的
2. 中断是激活操作系统的唯一方式

# 9. 人机交互的角度
1. OS改善人机界面，为用户使用计算机提供良好的环境
2. 人机交互设备包括**传统的终端设备**和**新型的模式识别设备**
3. OS的人机交互部分用于**控制有关设备运行**和**理解执行设备传来的命令**
4. 人机交互功能是决定计算机系统**友善性**的重要因素，是当今OS**研发热点**

## 9.1. 人机交互的初期发展
1. 交互式控制方式
   1. 行命令控制方式：1960年代开始使用，一行一行进行编辑
   2. 全屏幕控制方式：1970年代开始使用
2. 斯坦福研究所提出的发展计划
   1. 始于1960年代，1980年代广泛应用
   2. 强调**人**而不是**技术**是**人机交互**的中心
   3. 代表性成果：鼠标、菜单与窗口控制(单窗口)

## 9.2. 人机交互发展-WIMP界面
1. 缘起：70年代后期Xerox的原型机Star
2. 特征：窗口(Windows) (多窗口)、图标(Icons)、菜单(Menu) 和指示装置(Pointing Devices)为基础的图形用户界面WIMP
3. 得益：Apple最初采用并大力推动
4. 时间：1990年代开始广泛使用
5. 不足：不允许同时使用多个交互通道，从而产生人-机交互的不平衡
6. Apple的界面是WIWP的顶峰

## 9.3. 人机交互发展-多媒体计算机
1. 缘起：1985年的MPC
2. 把音频视屏、图形图像和人机交互控制结合起来，进行综合处理的计算机系统
3. 构成：多媒体硬件平台、多媒体OS 、图形用户接口、多媒体数据开发工具
4. 提供与时间有关的**时变媒体(何时体现感觉更好)**界面，既控制**信息呈现**，也控制何**时呈现/如何呈现**
5. 人机交互界面需要使用多种媒体，同时支持多通道交互整合，改善用户体验

## 9.4. 人机交互发展-虚拟现实系统(临境系统)
1. 缘起：1980年代的虚拟现实新型用户界面
2. VR通过计算机模拟三维虚拟世界，根据**观察点**、观察点改变的**导航**和对周围对象的操作，来模拟**临境**(身临其境)的感觉
3. 支持多通道交互整合，改善用户体验
4. 支持用户主动参与的高度自然的**三维**HCI，以及**语音识别、头部跟踪、视觉跟踪、姿势识别**等新型HCI
5. 容许用户产生含糊和不精确的输入

# 10. 程序接口的角度

## 10.1. 系统调用
1. 操作系统的程序接口：系统调用
   1. 操作系统实现的完成某种特定功能的过程
   2. 为所有运行程序提供访问操作系统的接口

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/24.png)

3. 为什么会出现系统调用？对上层如果暴露过于细粒度的操作，违背了**软件复用**的原则，所以我们将一系列的操作封装起来，作为系统调用来暴露。
4. 为什么操作系统不能使用名空间?(没有高级语言，为什么不可以通过名字来调用):操作系统处于系统底层之上，是不可以将高阶的名字，翻译成计算机操作系统可以理解的地址。底层是通过地址号来调用，而我们的按名访问本质上也只是完成了从名空间到地址空间的映射而已
   1. 操作系统诞生了名空间
   2. 文件系统需要使用名空间
5. 以32位系统为例，每个地址占4字节，以入口地址表的起地址$x_0$作为起点，依据功能号向下偏移$4*i$，读取系统调用处理子程序$Sub_i$的入口地址，然后执行$SUB_i$，执行完成之后，再返回用户空间。
6. 没有名称空间 -> 通过指针的地址计算做定位，表驱动按号索引，按号索引的前提是:
   1. 数据必须是按号连续排列的
   2. 表中的各数据结构的规格是一致的

## 10.2. 系统调用的实现机制
1. 陷入处理机制：计算机系统中控制和实现系统调用的机制
2. 陷入指令：也称**访管指令**，或**异常中断指令**，计算机系统为实现系统调用而引起处理器中断的指令
3. 每个系统调用都事先规定了**编号**，并在**约定**寄存器中规定了传递给内部处理程序的参数
4. 参数传递方法
   1. 访管指令或自陷指令自带参数，参数放置在指令后的若干单元，叫直接参数
   2. 指令后放置参数的地址，叫间接指令
   3. 通过CPU的通用寄存器传递参数，不适用于大量参数传递
   4. 在内存中开辟专门堆栈区传递参数
5. 操作系统实现系统调用的机制被称为陷阱或异常处理机制。
6. 由系统调用引起处理器中断的机器指令称为访管指令、自陷指令或中断指令，其中访管指令为非特权指令。

## 10.3. 系统调用的实现要点
1. 编写系统调用处理程序
2. 设计一张**系统调用入口地址表**，每个入口地址指向一个系统调用的处理程序，并包含系统调用自带参数的个数
3. 陷入处理机制需开辟现场保护区，以保存发生系统调用时的处理器现场

## 10.4. 系统调用的实现流程
1. 由硬件和操作系统来合作完成
   1. 中断是由硬件完成的
   2. 查入口地址和调用是由操作系统完成的
2. CPU执行程序中编写的由访管指令实现的系统调用时会产生异常，通过陷阱机制，处理器的状态由用户态转换为内核态，进入操作系统并执行相应的服务例程，以获得操作系统服务。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/7.png)

> 1. SUB子程序部分是绝对不能向用户暴露的，很危险
> 2. A部分，可以通过地址偏移来发起调用，$4*i+x_0$调用的是第i号系统调用。

1. 处理器状态包括用户态、内核态
   1. 用户态对应非特权指令
   2. 内核态对应特权和非特权指令
2. Linux中是通过为每个系统调用构造一个同名封装函数，将系统调用封装后供用户编程使用，详见P25

### 10.4.1. Transition from user to kernel mode
1. 特权指令和非特权指令混编实现代码
2. 如下图的Linux系统调用执行流程：两个进程之间切换，会损失一定的时间(内核消耗时间)，应该是会非常快速的进行切换的。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/4.png)

> 更多过程见课本P31-34


## 10.5. 系统调用和函数调用之间的区别
|                | 系统调用                                 | 函数调用                                   |
| -------------- | ---------------------------------------- | ------------------------------------------ |
| 调用形式       | 按地址转向                               | 功能号调用                                 |
| 实现方式       | 用户态转换内核态，在内核态执行访问核心栈 | 用户态                                     |
| 被调用代码位置 | 动态调用，服务例程位于操作系统内         | 静态调用，调用程序和被调用程序在同一程序内 |
| 提供方式       | 由操作系统提供                           | 编程语言提供                               |

# 11. 系统结构的角度

## 11.1. 操作系统软件的规模
1. 在计算机软件发展史上，OS是第一个大规模的软件系统
2. 1960年代，由OS开发所衍生的体系结构、模块化开发、测试与验证、演化与维护等研究，直接催生了软件工程这一新兴研究领域(另一个催生来源是DB应用引发的需求与规格)
3. OS作为大型软件，结构设计是关键

## 11.2. 操作系统软件的结构设计
> 内核设计是OS设计中最为复杂的部分

### 11.2.1. OS构件
1. 内核:核心的部分，操作系统必须有一个内核
   1. 一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作，通常驻留在内核空间，运行于内核他，具有直接访问硬件设备和所有内存空间的权限，是仅有的能够执行特权指令的程序。
   2. 内核的功能
      1. 中断处理
      2. 时钟管理
      3. 短程调度
      4. 原语管理：原语是内核中实现特定功能的不可中断过程
         1. 原语由内核实现，系统调用由系统进程实现
         2. 例子：通信原语、同步原语、I/O设备原语
   3. 内核的属性
      1. 内核是由中断驱动的
      2. 内核是不可抢占的
      3. 内核可以在屏蔽中断状态下进行
      4. 内核可以使用特权指令
2. 进程
3. 线程
4. 管程

### 11.2.2. 设计概念
1. 模块化
2. 层次式
3. 虚拟化

### 11.2.3. 操作系统内核
1. 单内核：内核中各部件杂然混居的形态，始于1960年代，广泛使用；如Unix/Linux，及Windows(自称采用混合内核的CS结构)，单内核导致内核会非常大

> 单内核结构的操作系统:写错了的Tanebaum,2015

2. 微内核：
   1. 仅将所有应用必须的核心功能放入内核，其他功能都在内核之外，由在用户态运行的服务进程实现
   2. 1980年代始，强调结构性部件与功能性部件的分离，大部分OS研究都集中在此，效率不高
   3. 详见课本P37页

> 微内核结构的操作系统，存在一定的不确定性，会增加切换的次数，带来一定的性能损耗

3. 混合内核：微内核和单内核的折中，较多组件在核心态中运行，以获得更快的执行速度
4. 外内核：尽可能减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化；部分嵌入式系统使用

> 安卓内核架构、C/S(Client/Server)模型

### 11.2.4. 单内核和微内核对比
### 11.2.5. 鸿蒙操作系统的软件架构

## 11.3. 操作系统实现的层次结构

### 11.3.1. 操作系统实现的第一种层次结构
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/8.png)

1. 现在文件系统也会划归到内核中

### 11.3.2. 操作系统实现的第二种层次结构
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec1/9.png)

1. 过程机制、指令解译、电路执行是由硬件完成，实现中断等机制。
2. 当前操作系统除了硬件电路以外都是由操作系统管理

# 12. 补充
1. $i++$ 返回成机器指令:
   1. $i -> R_0$
   2. $R_0 + 1 -> R_0$
   3. $R_0 -> i$

# 13. 操作系统运行模型
P42-44